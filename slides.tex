\documentclass[aspectratio=1610,14pt,t]{beamer}

% Colors
\usepackage{color}
\definecolor{mainorange}{HTML}{EC811B}
\definecolor{lightgrey}{HTML}{888888}
\definecolor{almostwhite}{HTML}{FEFEFE}

% Video support
\usepackage{multimedia}

% Syntax highlighting
\usepackage{minted}
\usepackage{alltt}
\newcommand\hi[1]{{\color{mainorange} \textbf{#1}}}

\usepackage{wasysym}

% Custom unicode symbols
\usepackage{newunicodechar}
\newcommand\Warning{%
 \makebox[1.4em][c]{%
 \makebox[0pt][c]{\raisebox{.1em}{\small!}}%
 \makebox[0pt][c]{\color{red}\Large$\bigtriangleup$}}}%

\newunicodechar{⚠}{\Warning}

% Theme
\usetheme[%
  subsectionpage=progressbar,
  numbering=fraction,
  progressbar=foot,
]{metropolis}

% Customization
\usepackage{pagecolor}
\setbeamertemplate{section in toc}[sections numbered]
\setbeamerfont{title}{size=\fontsize{30}{30}}
\setbeamerfont{block title}{size=\large}
\newcommand\sep{\textcolor{lightgrey}{\rule{\linewidth}{0.05mm}}}

% Positioning
% https://tex.stackexchange.com/a/34929/13059
\def\Put(#1,#2)#3{\leavevmode\makebox(0,0){\put(#1,#2){#3}}}

% Meta
\title{Embedded Rust}
\date{2020-06-18}
\author{Raphael Nestler (@rnestler), Noah Hüsser (@Yatekii)}
\institute{Rust Zürichsee Meetup}

\begin{document}

\pgfdeclareimage[width=\paperwidth]{bg}{background-dark.pdf}
\pagecolor{almostwhite}  % Prevent speakerdeck from optimizing away the bg color
\usebackgroundtemplate{\pgfuseimage{bg}}
\maketitle

% ----------------------------------------------------------------- %

\begin{frame}[c]{println!("\{:?\}", rnestler)}
  Hi! I'm Raphael (@rnestler).

  \pause I live in Rapperswil

  \pause I work at Sensirion ({\small \url{https://sensirion.com}}).

  \pause I'm a founding member of Coredump\\hackerspace ({\small \url{https://coredump.ch}}).
\end{frame}

\begin{frame}[c]{println!("\{:?\}", yatekii)}
  Hi! I'm Noah (@Yatekii).

  \pause I live in Lenzburg

  \pause I work at Technokrat ({\small \url{https://technokrat.ch/}}).

  \pause I started the probe-rs project ({\small \url{https://probe-rs}}).
\end{frame}

% ----------------------------------------------------------------- %

\begin{frame}[plain,noframenumbering]
  \frametitle{Outline}
  \setcounter{tocdepth}{1}
  \tableofcontents
\end{frame}

% ----------------------------------------------------------------- %

\pgfdeclareimage[width=\paperwidth]{bg}{background-light.pdf}
\usebackgroundtemplate{\pgfuseimage{bg}}

\section{Embedded Programming}

\begin{frame}[c]{What is an \emph{Embedded System}?}
  \begin{quote}
    A combination of computer hardware and software, and perhaps
    additional mechanical or other parts, designed to perform a dedicated
    function.
  \end{quote}
  Michael Barr. ``Embedded Systems Glossary''\footnote{\tiny\url{https://barrgroup.com/Embedded-Systems/Glossary-E\#embedded\_system}}
\end{frame}

\begin{frame}[c]{What is embedded programming?}
  \begin{itemize}
    \item Dedicated, not general purpose, µC system
    \item<1-> Baremetal
    \item<1-> Low-Level
    \item<2-> For this talk: Bare metal on Cortex-M MCUs
  \end{itemize}
\end{frame}

\begin{frame}[c]{Why do they say it's hard?}
  \begin{itemize}
    \item Harsh environment (No OS which protects you)
    \item Resource constrained (Remember dedicated?)
    \item Non-standard, Non-OSS toolchain
    \item Hard realtime requirements
    \item \ldots
  \end{itemize}
\end{frame}

\begin{frame}[c]{What does it mean for Rust?}
  \includegraphics[height=0.8\textheight]{img/no-std-gandalf.jpg}
\end{frame}


\begin{frame}[c]{Why is Rust awesome for it?}
  \begin{itemize}
    \item Zero cost abstractions!
    \item Provides safety at compiler level, not OS
    \item Expressive type system to encode constraints
  \end{itemize}
\end{frame}

\section{State of Embedded in 2020}
\begin{frame}[c]{The compiler}
  \begin{itemize}
    \item \texttt{const fn}
    \item \texttt{core::future::Future}
    \item \texttt{alloc} crate is stable
    \item \texttt{MaybeUninit<T>}: Fixes undefined behavior
  \end{itemize}
\end{frame}

\begin{frame}[c]{The compiler}
  \includegraphics[height=0.8\textheight]{img/did-i-forget-something.jpg}
\end{frame}

\begin{frame}[c]{\texttt{async} / \texttt{await} of course}

  \begin{quote}
    The \texttt{.await} is over, \texttt{async fn}s are here
  \end{quote}

  $\rightarrow$ We'll get to it
\end{frame}

\subsection{\texttt{const fn}}

\begin{frame}{Constant Fun!}
  \begin{columns}[t,onlytextwidth]
    \column{.4\textwidth}
    \begin{figure}
    \includegraphics[width=\textwidth]{img/const-all-the-fn.jpg}
    \end{figure}
    \column{.6\textwidth}
    \begin{itemize}
      \item Stabilized at the end of 2018
      \item Tons of functions got const during 2019
      \item More functions from libcore
      \item More features (destructuring, bindings, assignment, \ldots)
    \end{itemize}
  \end{columns}
\end{frame}

\begin{frame}[c,fragile]{Constant Fun Example}
An example from the lin-bus crate\footnote{\url{https://github.com/Sensirion/lin-bus-rs/blob/e89739e326daf091803373419a4d60d0888422fc/src/frame.rs}}
  \begin{minted}[fontsize=\footnotesize]{rust}
/// Calculate the PID from an ID.
/// P0 = ID0 ^ ID1 ^ ID2 ^ ID4
/// P1 = ¬(ID1 ^ ID3 ^ ID4 ^ ID5)
const fn from_id_const(id: u8) -> PID {
    // count parity bits and check if they are even / odd
    let p0 = (id & 0b1_0111).count_ones() as u8 & 0b1;
    let p1 = ((id & 0b11_1010).count_ones() as u8 + 1) & 0b1;
    PID(id | (p0 << 6u8) | (p1 << 7u8))
}
  \end{minted}
\end{frame}

\begin{frame}[c,fragile]{Less Constant Fun Example}
  Saw the problem?\pause
  \begin{minted}[fontsize=\footnotesize]{rust}
pub fn from_id(id: u8) -> PID {
    assert!(id < 64, "ID must be less than 64");
    PID::from_id_const(id)
}
  \end{minted}
\end{frame}

\begin{frame}{Constant Future}
  What is missing?
  \begin{itemize}
    % Implementation is here, but design not finalized. You can use it on nightly.
    \item Const generics\footnote{\url{https://github.com/rust-lang/rust/issues/44580}}
    % Important to have compile time assertions, think static_assert in C++
    \item Panicking in constants\footnote{\url{https://github.com/rust-lang/rust/issues/51999}}
  \end{itemize}
\end{frame}


\begin{frame}[c]{New Platform Support}
  \begin{itemize}
    \item AVR basic support got merged\footnote{\url{https://github.com/rust-lang/rust/pull/69478}} \footnote{\url{https://github.com/rust-lang/rust/issues/44052}}
    \item New ARM targets: thumbv7neon-linux-\{androideabi,gnueabihf\}, armv\{6/7\}-unknown-freebsd-gnueabihf, aarch64-unknown-none-*
    \item New RISC-V targets: riscv64imac-unknown-none-elf, riscv64gc-unknown-none-elf, riscv32i-unknown-none-elf
    \item Sony PSP support\footnote{\url{https://github.com/rust-lang/rust/pull/72062}}
  \end{itemize}
\end{frame}

\begin{frame}[c]{RTFM $\rightarrow$ RTIC}
  \begin{itemize}
    \item RTFM got renamed $\rightarrow$ RTIC\footnote{\url{https://rtic.rs/0.5/book/en/migration_rtic.html}}
    \item Examples: https://github.com/coredump-ch/nixie-counter/tree/master/firmware/
  \end{itemize}
\end{frame}

\subsection{Embedded HAL}

\begin{frame}[c]{What is the Embedded HAL?}
  \begin{itemize}
  \item Unified interface to the same HW functionality which has different
    interfaces
  \item Higher level crates (drivers) are write once use always
  \item Nice examples: shtc3
    driver\footnote{\url{https://github.com/dbrgn/shtcx-rs}} developed and
    debugged on a  Raspberry Pi and used with an SMT32
  \end{itemize}
\end{frame}

\begin{frame}[c]{SHTC3 Driver as Example}
  \includegraphics[height=0.8\textheight]{./img/gfroerli.jpg}
\end{frame}

\begin{frame}[c]{SHTC3 Driver as Example}
\movie[autostart,loop]{\includegraphics[height=0.8\textheight]{./img/shtc3-monitor-0.png}}{./img/shtc3-monitor.mp4}
\end{frame}

\begin{frame}[c]{Embedded HAL --- Challanges / Future}
  \begin{itemize}
  \item It's hard to define traits which work everywhere
  % Single vs. multi byte transfer, DMA? SPI CS? Own the HW device?:w

  \item How to define async traits?
  \item Ecosystem needs to move as a whole on breaking changes
  \item 1.0 Release planed\footnote{\url{https://github.com/rust-embedded/embedded-hal/issues/177}}
  \end{itemize}
\end{frame}

\begin{frame}[c]{More Resources}
  \begin{itemize}
    \item The Rust Embedded WG Blog\footnote{\url{https://rust-embedded.github.io/blog/}}
    \item The Rust Embedded Book\footnote{\url{https://docs.rust-embedded.org/book/}}
    \item The Discovery book\footnote{\url{https://docs.rust-embedded.org/discovery/index.html}}
    \item Awesome Embedded Rust\footnote{\url{https://github.com/rust-embedded/awesome-embedded-rust}}
  \end{itemize}
\end{frame}

\section{Embedded development}

\begin{frame}[c]{Embedded development}
  \begin{itemize}
    % On an x86 target you can load the program directly from disk to RAM from with in your os.
    % Where you also coded, compiled and debugged your program.
    % You get convenient tools for output and interaction such as the commandline, a debugger or even a webbrowser.
    \item Software is written on a host instead of the target.
    % On a microchip we have no such feedback.
    % We develop the software, flash it to the microchip with a magic tool (at least to many folks it is)
    % and hope it runs properly. Oftentimes we have to measure HW signals with some special equippment.
    \item The microchip has no direct feedback.
    % We need a tool to talk with the chip. We somehow need our host to talk to the microchip.
    % To download the binary, to run a debugger and to do custom interaction.
    % Interfaces exist, but the PC doesn't understand them. Similar to an SPI peripheral and an SPI driver,
    % We need to write the driver for those interfaces. SWD and JTAG.
    \item A middleman is needed (soft- \& hardware).
    % This magic tool you always used but never really looked into is probe-rs, like many others.
    \item probe-rs
  \end{itemize}
\end{frame}

\begin{frame}[c]{Hardware Probes}
  \begin{itemize}
    % This is the standard we encourage everyone to use. It is developed by ARM and supports SWD as well as JTag, which makes it suitable for RISC-V too.
    % CMSIS-DAP has the capability to go very fast and has no hidden pitfalls or sealed behavior.
    \item CMSIS-DAP
    % This is the debug probes provided by ST. They come in various forms and there is cheap china clones.
    % Unfortunately their API is closed source and only reverse engineered. That by iself is manageable. But the ST-Link firmwares so some magic
    % Which sometimes leads to unexpected results. For their v3 series they even locked usage to ST products only. This is very sad as the HW is great.
    \item ST-Link
    % The J-Link is a properietary probe by Segger, a german company. Their probes go way back and provide the biggest and most complete featureset.
    % The API was released in a PDF once and can be pulled from the internet time machine.
    % There is more (and even more expensive) probes from other manufacturers which are more unknown but have the same issues & features in essence.
    \item J-Link
    % The Blackmagic Probe is an open source probe that can be used without any additional tooling on the PC as it has the GDB stub built in.
    % This enables users to directly use the probe without installing anything. This is great. What's not great is that you have to update the probe firmware
    % whenever you want to add a new target. And of course, GDB has no more right to exist in the embedded world; more on that later.
    \item Blackmagic Probe
    \item ...
  \end{itemize}
\end{frame}

\begin{frame}[c]{Software Tooling}
  \begin{itemize}
    % There is a sea of tools for the various microchips there are. There is many architectures for which there are different tools each.
    % This ensures that there is a tool for each task there is.
    % You also have the plus of being able to choose the tool that fits you best.
    \item[+] Diverse
    \item[+] Huge featureset
    % Many of those tools are directly from the manufacturers themselves. This can be a plus as the manufacturer knows their product best
    % and is able to use this knowledge to make the best tool possible.
    % The manufacturers most likely will put in the least effort to make their chips work with the tooling and don't provide any extended functionality.
    \item[+] From the manufacturers themselves
    % The tools all have different UIs and APIs. This is especially annoying when you have to work with different tools for different chips.
    \item[−] Different interfaces
    % Especially the good tooling is proprietary. An exception here is OpenOCD which is featureful and Open Source.
    % While cost can be one problem about proprietary tools, some of them are free and I mostly take issue with the fact,
    % that if you want to use the tooling slightly different than intended by the manufacturer or happen to stumble upon a bug,
    % you are in trouble.
    \item[−] Proprietary
    % Most of the existing tooling stems from old ages and oftentimes is tedious to use.
    % Lots of weird config files or not even the possibility to really config things at all are only some of the issues here.
    % Many of the tools offer a way to flash a chip and maybe a GDB server but that's about it.
    % Then you are forced to do everything through GDB which is not necessarily a great choice.
    \item[−] Cumbersome to use
    % Many tools discourage contributions by chaotic source control (patch based gerrit with no real mainlining)
    % or suboptimal language choices (such as Python which is not weary of any concept of bits).
    \item[−] Contributing discouraged
    % GDB is used in combination with most tooling. Whilst the sanity of GDB itself is quite arguable, it is quite powerful in terms of debugging functionaility.
    % It is a very old, more or less one-file, C codebase. The GDB API is not very modern and lacks in many points. Optimally we want to skip GDB.
    % GDB is not embedded aware. Most of the required things for embedded have been added with the extension API of GDB, which is done differently by every tool.
    \item[−] Everything is GDB-based
  \end{itemize}
\end{frame}

\begin{frame}[c]{So what is probe-rs?}
  \begin{itemize}
    \item Rust Library
    \item Talks to ARM and RISC-V cores
    \item Supports CMSIS-DAP, ST-Link, J-Link
  \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{Memory Access}
  \begin{minted}[fontsize=\small]{rust}
    use probe_rs::Session;
    use probe_rs::MemoryInterface;

    let mut session = Session::auto_attach("nrf52")?;
    let mut core = session.core(0)?;

    // Read a single 32 bit word.
    let word = core.read_word_32(0x2000_0000)?;
  \end{minted}
\end{frame}

\begin{frame}[c,fragile]{CPU Control}
  \begin{minted}[fontsize=\small]{rust}
    use probe_rs::Session;
    use probe_rs::MemoryInterface;

    let mut session = Session::auto_attach("nrf52")?;
    let mut core = session.core(0)?;

    // Reset the CPU.
    core.reset()?;
  \end{minted}
\end{frame}

\begin{frame}[c,fragile]{Breakpoint Manipulation}
  \begin{minted}[fontsize=\small]{rust}
    use probe_rs::Session;
    use probe_rs::MemoryInterface;

    let mut session = Session::auto_attach("nrf52")?;
    let mut core = session.core(0)?;

    // Set a breakpoint.
    core.set_hw_breakpoint(0x1500_2000)?;
  \end{minted}
\end{frame}

\begin{frame}[c,fragile]{Flashing}
  \begin{itemize}
    \item we use CMSIS-Packs
    \item thousands of available targets
    \item custom format for more info
  \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{cargo flash}
  \begin{itemize}
    \item slim cargo plugin
    \item for flashing targets
    \item for quick entry
    \item https://github.com/probe-rs/cargo-flash
  \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{cargo embed}
  \begin{itemize}
    \item fat client embedded toolkit
    \item flashing
    \item RTT
    \item ITM
    \item GDB
    \item more?
    \item highly configurable
    \item https://github.com/probe-rs/cargo-embed
  \end{itemize}
\end{frame}

\section{probe\_rs.await?;}

\begin{frame}[c,fragile]{vscode}
  \begin{itemize}
    \item VSCode plugin
    \item Microsoft DAP
    \item no GDB required
    \item Modern, extensive API (JSON)
    \item async
    \item working, with limitations
    \item https://github.com/probe-rs/vscode
  \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{ITM}
  \begin{itemize}
    \item powerful data streaming from the target
    \item ISR events
    \item memory access events
    \item custom binary data
    \item working, not on master yet
    \item https://github.com/probe-rs/probe-rs/pull/145
  \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{Custom Hooks}
  \begin{itemize}
    \item use CMSIS-Pack hooks
    \item uses custom WASM format
    \item poc, no PR yet
  \end{itemize}
\end{frame}

\begin{frame}[c,fragile]{rs-probe}
  \begin{itemize}
    \item open source probe
    \item pure rust firmware
    \item extremely fast (500 Mbit/s)
    \item uses standard ARM API
    \item can stream DAP, ITM and UART data
    \item https://github.com/korken89/hs-probe
  \end{itemize}
\end{frame}

\begin{frame}[c]{Contribute}
  \begin{itemize}
    \item https://github.com/probe-rs/probe-rs
    \item \#probe-rs:matrix.org on Matrix
    \item Questions \& Bugreports very welcome
    \item PRs very welcome
  \end{itemize}
\end{frame}

% ----------------------------------------------------------------- %

{
\setbeamertemplate{footline}{}
\pgfdeclareimage[width=\paperwidth]{bg}{background-inverted.pdf}
\usebackgroundtemplate{\pgfuseimage{bg}}
\begin{frame}[standout]
  \begin{centering}
    {\Huge Thank you!}\\
    {\normalsize \url{https://coredump.ch}}\\
  \end{centering}
  {\small Slides: \url{https://github.com/rust-zurichsee/meetups/}}\\
  \vspace{3cm}
\end{frame}
}


\setbeamertemplate{section in toc}[sections numbered]
\pgfdeclareimage[width=\paperwidth]{bg}{background-light.pdf}
\usebackgroundtemplate{\pgfuseimage{bg}}
\appendix
\section{\appendixname}
\frame{\tableofcontents}
\subsection{Alloc crate}

\begin{frame}[c]{alloc crate}
  \begin{itemize}
    \item alloc allows you to use a subset of std (e.g. \texttt{Vec, Box, Arc})
      in \texttt{\#![no\_std]} environments if the environment has access to
      heap memory allocation.\footnote{\url{https://github.com/rust-lang/rfcs/blob/master/text/2480-liballoc.md}}
    \item You need to define a \texttt{\#[global\_allocator]}\footnote{\url{https://doc.rust-lang.org/stable/std/alloc/\#the-global\_allocator-attribute}}
    \item Check out \url{https://crates.io/crates/alloc-cortex-m}
  \end{itemize}
\end{frame}

\subsection{svd2rust}

\begin{frame}[c]{svd2rust}
  \begin{itemize}
    \item Every Cortex-M μC vendor must provide an SVD (System View
      Descriptions) file
    \item SVD is an XML standard to describe peripheral registers
    \item svd2rust\footnote{\url{https://github.com/rust-embedded/svd2rust}}:
      Generate Rust register maps (structs) from SVD files
  \end{itemize}
\end{frame}

\end{document}
